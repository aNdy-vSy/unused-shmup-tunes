;
; 'Unused Shmup Music'
;
; Released by Cosine in 2019
;
; www.cosine.org.uk
;
; A simple music selector featuring unused
; music originally written for some
; shoot 'em up space type games!
;
; Code, graphics and music by aNdy/Cosine
;
; Thanks to T.M.R/Cosine for all your patience!
;
; This source is formatted for the ACME cross assembler
; which can be downloaded from...
; http://sourceforge.net/projects/acme-crossass/
;
; The final build was compressed and squished using
; Exomizer 2 which can be downloaded from...
; http://hem.bredband.net/magli143/exo/
;
; Questions about this code or about how the binaries
; were created can be asked by emailing aNdy...
; andy@cosine.org.uk
;

; the name and file format for the assembled program

		!to "unused_shmups.prg",cbm

; drag in some charset, sprite and music binaries!	

		* = $0900
music5	!binary "data/killmusic.prg",,2

		* = $2000
		!binary "data/charset.chr"

		* = $2800
		!binary "data/sprites.spr"			
		
		* = $6000
music1	!binary "data/title_tune.prg",,2

		* = $7000
music3	!binary "data/level_tune.prg",,2

		* = $7d00
music4	!binary "data/ready_over_tunes.prg",,2


		
; position of the raster interrupt(s) on-screen
; 'rp' is short for 'raster position'! duh!

raster_1_pos	= $00			; start of screen
raster_2_pos	= $b6			; end of logo and start of sprite starfield top section
raster_3_pos	= $db			; start of sprite starfield bottom section

; some labels assignments (keyboard locations)

pra  =  $dc00					; cia#1 (port register a)
prb  =  $dc01					; cia#1 (port register b)

; some more label assignments (variables)

raster_num			= $50		; raster counter stores which split we are working in
sync				= $51		; interupt sync variable
print				= $52		; print screen on/off variable
colourwash_count	= $53		; colour pulse counter for wash effect
colourwash_timer	= $54		; colour pulse timer for wash effect
scroll_x			= $55		; title scroller screen position
scroll_pos			= $56		; titles scroller position - $02 bytes used
tune_num			= $58		; tune number variable
anim_timer			= $59		; animation timer for top sprites
msb_flag1			= $5a		; flag for setting top starfield sprites msb
msb_flag2			= $5b		; flag for setting bottom starfield sprites msb
msb_flag3			= $5c		; flag for setting logo 'pulse' sprites msb
pulse_timer			= $5d		; logo pulse timer
pulse_flag			= $5e		; logo pulse flag (on/off)


; add a BASIC startline (SYS 16384) for auto-run after loading

		* = $0801
		!word code_entry-2
		!byte $00,$00,$9e
		!text "16384"
		!byte $00,$00,$00

; entry point for the code

		* = $4000				; hence sys 16384!

; stop interrupts, disable the roms and set up nmi and irq interrupt pointers		
				
code_entry

		sei						; disable maskable IRQs
		
		lda #$35				; kill EVERYTHING (MWHAHA!) except $f000-$ffff
		sta $01
		
; setup nmi

		lda #<nmi				; some nmi stuff
		sta $fffa
		lda #>nmi
		sta $fffb
		
; setup irq's

		lda #<int				; some irq stuff
		sta $fffe
		lda #>int
		sta $ffff

		lda #$7f
		sta $dc0d				; disable timer interrupts which can be generated by the two CIA chips
		sta $dd0d				; the kernal uses such an interrupt to flash the cursor and scan
								; the keyboard, so we better stop it

		lda $dc0d				; by reading this two registers we negate any pending CIA irqs.
		lda $dd0d				; if we don't do this, a pending CIA irq might occur after we
								; finish setting up our irq. we don't want that to happen.

		lda #raster_1_pos		; starting point of raster on screen ($00)
		sta $d012

		lda #$1b				; as there are more than 256 rasterlines, the topmost bit of $d011 serves as
		sta $d011				; the 9th bit for the rasterline we want our irq to be triggered.
		
		lda #$01
		sta $d019				; clear interupt bit
		sta $d01a				; tell vicii to generate interupt

		lda #$35				; turn off basic and kernal rom thus
		sta $01					; c64 now sees RAM everywhere except at $d000-$e000
		
		lda #$18				; use our custom font charset
		sta $d018

		cli

; first run screen setup =========================		
	
; setup for the very first run by clearing the screen,
; then reading data from the screen and colour ram tables
; (at the bottom of this code) to print the the main
; display, on this occasion our PETSCII logo and text 

		jsr clear_screen		; clear screen with subroutine
		
		ldx #$00				; zero x register
printscrnram_loop				; load up whatver is in the screen
		lda screen_ram,x		; ram table and write to the
		sta $0400,x				; screen ram
		lda screen_ram+250,x
		sta $0400+250,x
		lda screen_ram+500,x
		sta $0400+500,x
		lda screen_ram+750,x
		sta $0400+750,x	
		inx
		cpx #$fa				; done 250 writes?
		bne printscrnram_loop	; all written? no? loop back!
								; yes? then...
		ldx #$00				; zero x register
printcolram_loop				; load whatever is in the colour
		lda colour_ram,x		; ram table and write to the
		sta $d800,x				; colour ram
		lda colour_ram+250,x
		sta $d800+250,x	
		lda colour_ram+500,x
		sta $d800+500,x	
		lda colour_ram+750,x
		sta $d800+750,x	
		inx
		cpx #$fa				; done 250 writes?
		bne printcolram_loop	; all written? no? loop back!
		
; reset the message scroller for first run

		jsr scroll_reset		; reset 'scroller' subroutine
		
		lda #$50
		sta scroll_x

; prepare the music for first run		
				
		lda #$05				; start with tune 1 (title)
		sta tune_num			; already selected
		
		lda #$00				; setup the driver to
		jsr music5+$00			; play the title music
		
; set up raster handler for first raster at the top of the screen
		
		lda #$01
		sta raster_num
		
; set up timer and flag for logo pulse on first run

		lda #$00				; zero the accumalator
		sta pulse_flag			; pulse flag is '0' (off)
		
		lda #$fa				; put 250 in...
		sta pulse_timer			; ...the pulse timer 'variable'
		
; main loop code =========================================

; now the main loop

mainloop
								; call these subroutines...
		jsr sync_wait			; wait until irq finishes!
		jsr write_message		; write the scroller message
		jsr keycheck			; check if keys are being pressed?
		
		jmp mainloop			; now back to 'mainloop' up by there
								; and call the subroutines again!

										
; subroutines called from above code =====================		
		

; key press check subroutine -----------------------------			
		
keycheck
								; lets check some keys
		lda #$7f 				; test $dc00 bit row 7 ($7F)
        sta pra
        lda prb
		
        cmp #$fe				; key '1' pressed?
		beq set_tune1			; then set tune 1 routine
		
		cmp #$f7				; key '2' pressed?
		beq set_tune2			; then set tune 2 routine
		
		cmp #$7f				; key 'run/stop' pressed?
		beq stop_music			; then stop_music routine		

								; now swap to different row!
		lda #$fd  				; test $dc00 bit row 1 ($fd)
        sta pra
        lda prb
        
        cmp #$fe				; key '3' pressed?
		beq set_tune3			; then set tune 3 routine

		cmp #$f7				; key '4' pressed?
		beq	set_tune4			; then set tune 4 routine		
			
		rts						; return to from where this was called

; set the selected tune depending on keypress subroutine ---------			
				
set_tune1

		jsr key_debounce		; wait for key release
		
		lda tune_num			; is this tune already playing?
		cmp #$01				; if so, then don't set the
		beq skip_set_tune		; tune again, skip back to mainloop			
								; if not, then
		lda #$01				; select tune 1
		sta tune_num
		
		lda #$00				; the title music
		jsr music1+$00

		jsr hilite_c			; clear all hi-lites					
		jsr hilite_1			; hilite the tune playing
		
		jmp mainloop
		
set_tune2

		jsr key_debounce		; wait for key release

		lda tune_num			; is this tune already playing?
		cmp #$02				; if so, then don't set the
		beq skip_set_tune		; tune again, skip back to mainloop			
								; if not, then				
		lda #$02				; select tune 1
		sta tune_num
		
		lda #$01				; the get ready music
		jsr music4+$00
		
		jsr hilite_c			; clear all hi-lites		
		jsr hilite_2			; hi-lite the tune playing

		jmp mainloop

set_tune3

		jsr key_debounce		; wait for key release

		lda tune_num			; is this tune already playing?
		cmp #$03				; if so, then don't set the
		beq skip_set_tune		; tune again, skip back to mainloop			
								; if not, then
		lda #$03				; select tune 3
		sta tune_num
		
		lda #$00				; the in-game music
		jsr music3+$00
			
		jsr hilite_c			; clear all hi-lites	
		jsr hilite_3			; hilite the tune playing		
		
		jmp mainloop
		
set_tune4

		jsr key_debounce		; wait for key release

		lda tune_num			; is this tune already playing?
		cmp #$04				; if so, then don't set the
		beq skip_set_tune		; tune again, skip back to mainloop			
								; if not, then		
		lda #$04				; select tune 4
		sta tune_num
		
		lda #$00				; the game over music
		jsr music4+$00

		jsr hilite_c			; clear all hi-lites	
		jsr hilite_4			; hilite the tune playing

		jmp mainloop

stop_music

		jsr key_debounce		; wait for key release

		lda tune_num			; has r/s already been pressed?
		cmp #$05				; if so, then don't stop
		beq skip_set_tune		; again, skip back to mainloop
								; if not, then		
		lda #$05				; select 'empty' music track
		sta tune_num
		
		lda #$00				; the 'empty' music track
		jsr music5+$00			; that stops music (cheat!)
		
		jsr hilite_c			; clear all hi-lites			

skip_set_tune
				
		jmp mainloop		
		

; clear screen subroutine ----------------------------------		

clear_screen

        lda #$00				; load 0 for black
		sta $d021				; store to background! change colour!
		sta $d020				; store to border! change colour!

		ldx #$00				; zero x register		
		lda #$20				; value for 'empty space' in accum

clsloop							; clear screen loop!
		sta $0400,x
		sta $0500,x
		sta $0600,x
		sta $0700,x
		inx
		bne clsloop
		
	   	rts						; return to where this was called from
	   	
	   	
; key press debounce subroutine ------------------------------- 		

key_debounce

		lda prb					; check the keyboard...
		cmp #$ff				; an idiot is still pressing a key?
		bne key_debounce		; lock them in a loop till they stop!
		
		rts						; now go back to where from this was called


; irq sync wait subroutine ---------------------------------- 
	   	 
sync_wait						; wait for sync update in irq code!
		lda #$00				; waits until the sync flag is
		sta sync				; set at the end of the interupt
sw_loop							; code further down.
		cmp sync				; no code in the main loop above
		beq sw_loop				; is executed until the interupt
								; has run it's course!
		rts

		
; update 'scrolling' message subroutine --------------------- 
		
write_message
	
		ldx scroll_x
		cpx #$28
		bcs scroll_cnt

; fetch a character from the text table

scroll_read

		ldy #$00
		lda (scroll_pos),y
		bne scroll_write
		
		jsr scroll_reset
		
		jmp scroll_read

; write that character to the screen
		
scroll_write

		sta $07c0,x

; update the text position

		inc scroll_pos+$00
		bne *+$04
		inc scroll_pos+$01

; store the current text position		
		
scroll_cnt

		inx
		stx scroll_x
		
		rts						; return to where this was called from

; reset the scroll message		
				
scroll_reset

		lda #<mess_text
		sta scroll_pos+$00
		lda #>mess_text
		sta scroll_pos+$01
		
		rts						; return to where this was called from
		
		
; tune 'arrow' highlight subroutines ---------------------------

; tune 1 highlight

hilite_1

		ldx #$00				; zero x register to count
hilite1_loop
		lda lefthilite,x		; reversed close angle bracket
		sta $06f8,x				; disguised as a right pointing arrow!
		lda righthilite,x		; reversed open angle bracket
		sta $06f8+34,x			; disguised as a left pointing arrow
		inx
		cpx #$06				; six arrows drawn yet?
		bne	hilite1_loop		; no? go back up to loop start
								; yes?
		rts						; go back to where this was called from!
		
; tune 2 highlight

hilite_2

		ldx #$00
hilite2_loop
		lda lefthilite,x
		sta $0720,x
		lda righthilite,x
		sta $0720+34,x
		inx
		cpx #$06
		bne	hilite2_loop
		
		rts
		
; tune 3 highlight

hilite_3

		ldx #$00
hilite3_loop
		lda lefthilite,x
		sta $0748,x
		lda righthilite,x
		sta $0748+34,x
		inx
		cpx #$06
		bne	hilite3_loop
		
		rts							

; tune 4 highlight

hilite_4

		ldx #$00
hilite4_loop
		lda lefthilite,x
		sta $0770,x
		lda righthilite,x
		sta $0770+34,x
		inx
		cpx #$06
		bne	hilite4_loop
		
		rts
		
; clear all tune highlights

hilite_c

		ldx #$00
		lda #$20				; use a space character to clear arrows!
hilitec_loop
		sta $06f8,x				; first tune, left hand side arrow hilites!
		sta $06f8+34,x			; and the right hand side!
		sta $0720,x				; then the second tune, left hand side 
		sta $0720+34,x			; and the right hand side
		sta $0748,x				; third tune, left
		sta $0748+34,x			; right
		sta $0770,x				; fourth tune, left
		sta $0770+34,x			; right
		inx
		cpx #$06				; six spaces drawn on each side?
		bne	hilitec_loop		; no? back to the start of the loop!
								; yes?
		rts						; return to where this subrout was called from!
				 	 	
	   	
; end subroutines =====================================		
			

; IRQ interrupt code =================================

int
		pha  
		txa
		pha
		tya
		pha
		
		lda $d019
		and #$01
		sta $d019
		bne intr_trigd
		
		jmp irq_exit			; no interupt triggered? exit irq code!
		
; an interrupt has triggered!?!
; which split should we run? let's check...

intr_trigd

		lda raster_num			; load up the raster_num variable
		
		cmp #$02				; is it set to '2'?
		bne *+$05				; no? then jump down to check for '3'
		jmp irq_rout2			; yes? jump down to irq_rout2!

		cmp #$03				; is the raster_num set to '3'?
		bne *+$05				; no? jump down and run irq_rout1!
		jmp irq_rout3			; yes? jump down to irq_rout3!
				

; raster split 1 code -------------------------------

irq_rout1						; top section of the screen
	
		lda #$06				; change colour to blue border
		sta $d020				; for top part of screen

; set interrupt handler ready for split 2

		lda #$02				; next run through this interupt code,
		sta raster_num			; split 2 should execute, a bit
		lda #raster_2_pos		; further down...
		sta $d012
		
; test to see if logo pulse should be displayed?

		lda pulse_flag			; load up the pulse flag
		cmp #$01				; is it set to $01 (on)? 
		beq pulse_logo			; if yes, go down to
								; 'pulse_logo'		
		jmp play_music			; if no, jump down to
								; 'play_music'
	
; turn on and position 8 sprites for the logo pulse!

pulse_logo

		lda #$ff				; turn on ...	
		sta $d015				; all 8 of dem sprite thangs!
		sta $d01c				; and make 'em all multicolour!
		sta $d01b				; AND put them behind the logo!
		
		lda #$0f				; light grey...
		sta $d025				; ...into multicolour 1 register
		lda #$0b				; dark grey...
		sta $d026				; ...into multicolour 2 register
		
		ldx #$00				; zero both the...
		ldy #$00				; ...x and y registers
set_sprites
		lda t_sprite_x,x		; drag in the x coord for a sprite from table
		sta $d000,y				; store in sprites x position register
		lda t_sprite_msb		; load up sprite msb table
		sta $d010				; store to msb register
		lda t_sprite_y,x		; load in the y coord for a sprite from table
		sta $d001,y				; store in that sprite's y position register
		lda t_sprite_cols,x		; load a colour from the colour table
		sta $d027,x				; store in that sprite's colour register
		lda t_sprite_def,x		; and we need to load a definition for the sprite!
		sta $07f8,x				; and store it!
		iny
		iny
		inx
		cpx #$08				; have we done all 8 sprites?
		bne set_sprites			; no? back to set_sprites then please!
		
		ldx #$00				; reset x register to zero!
		lda #$01				; load 1 to accumaltor!
		sta msb_flag3			; set the temp value used for msb juggling
reposition_sprites_t			; lets move the sprites!
		lda t_sprite_x,x		; load x position from the table
		clc						; clear carry flag!
		adc t_sprite_speed,x	; add whatever is in the sprite speed table
		sta t_sprite_x,x		; store new sprite x position!

		bcc no_msb_t			; skip the msb wrangling if carry isn't set

		lda t_sprite_msb		; read the current msb value
		eor msb_flag3			; toggle the bit for the sprite being processed
		sta t_sprite_msb		; write the current msb value

no_msb_t
		asl msb_flag3			; shift the bit used for toggling msb up for the next pass
		inx
		cpx #$08					; have we done all 8 sprites????
		bne reposition_sprites_t	; no? back to start of loop please!
		
; update the sprite animation

; note... altering the cpx value just below
; changes the animation speed by altering
; how many frames the timer waits for
; before executing the animation code!
; bigger value equals slower animation!

		ldx anim_timer			; load up the anim_timer
		inx						; increase it by '1'
		cpx #$04				; is the timer equal to '4' yet?
		bne anim_skip			; no? don't update animation!
								; yes? better do some animation then!
		ldx #$00
anim_update
		lda t_sprite_def,x		; load up the sprite's definition from the table
		clc						; clear carry flag
		adc #$01				; add 1
		cmp #$a8				; is the value now $a8 (last animation frame)?
		bne *+$04				; no? jump down to inx instruction
		lda #$a0				; yes? reset value to $a0 (first animation frame)
		sta t_sprite_def,x		; store to sprite definition table
		inx
		cpx #$08				; all 8 sprites done?
		bne anim_update			; no? back to start of the loop then!
								; yes?
		ldx #$00				; load x register with '0'
anim_skip						; to reset anim_timer and...	
		stx anim_timer			; store x register to anim_timer
		
; has the pulse travelled all the way across the screen?	

		lda t_sprite_msb		; are the sprites in the msb?
		and #$01				; check sprite '0'
		beq play_music			; not in msb? play some music!
								; yes? then where in the msb?
								; let's check...
		ldx #$00						
		lda t_sprite_x,x		; load up sprite 0's current x position...
		cmp #$58				; futher than '88' off right hand side?
		bcs pulse_off			; yes? branch to 'pulse_off'
								; no?
		jmp play_music			; play some music!
		
pulse_off

		lda #$00				; set the pulse flag to
		sta pulse_flag			; zero, which is 'off'
		
		ldx #$00
reset_sprites_x		
        lda t_sprite_xreset,x	; copy the sprite reset table (all zero's)
		sta t_sprite_x,x		; to the sprite x table, to set the
		inx						; sprites to the left hand side of the screen
		cpx #$08				; all 8 sprites done?
		bne reset_sprites_x		; no? loop back!
		
		lda #$00				; reset the sprite msb table to zero so we
		sta t_sprite_msb		; can go back to the screens left hand side! 
				
; call music player	and play dat choon!

play_music

		lda tune_num			; which tune should be playing?
		
		cmp #$01				; tune 1 (title)?
		beq playtune1			; then play tune 1!
		
		cmp #$02				; tune 2 (get ready)?
		beq playtune2			; then play tune 2!
		
		cmp #$03				; tune 3 (level in game)?
		beq playtune3			; then play tune 3!
		
		cmp #$04				; tune 4 (game over)?
		beq playtune4			; then play tune 4!

		cmp #$05				; stop music beep
		beq stop_tunes			; tune 1, sub-tune 2					

playtune1
	
		jsr music1+$03			; play tune 1!
		jmp irq_exit			; now exit the interupt!
		
playtune2
	
		jsr music4+$03			; play tune 2!
		jmp irq_exit		
		
playtune3
	
		jsr music3+$03			; play tune 3!
		jmp irq_exit
		
playtune4
	
		jsr music4+$03			; play tune 4!
		jmp irq_exit							

stop_tunes
	
		jsr music5+$03			; stop music with a
		jmp irq_exit			; sub-tune			
		
		
; raster split 2 code ------------------------------------

irq_rout2

; set interrupt handler ready for split 3
	
		lda #$03
		sta raster_num
		lda #raster_3_pos
		sta $d012

		lda #$00				; change colour to black border
		sta $d020				; for bottom third of screen
		
; recycle the 8 sprites in the bottom part of the screen
; which are being used for the top part of the starfield!
  

		lda #$ff				; turn on..
		sta $d015				; all 8 sprites!
		lda #$00				; make these sprites
		sta $d01c				; hires though!

		ldx #$00
		ldy #$00
draw_sprites_b1					; lets draw the top part of the starfield
		lda b1_sprite_x,x		; load in the x pos from the table
		sta $d000,y				; store in the sprites x register
		lda b1_sprite_msb		; check if we're in the MSB
		sta $d010			
		lda b1_sprite_y,x
		sta $d001,y
		lda b1_sprite_cols,x
		sta $d027,x
		lda b1_sprite_def,x
		sta $07f8,x
		iny
		iny
		inx
		cpx #$08
		bne draw_sprites_b1
		
		
		ldx #$00
		lda #$01
		sta msb_flag1			; set the temp value used for MSB juggling
reposition_sprites_b1
		lda b1_sprite_x,x
		clc
		adc b1_sprite_speed,x
		sta b1_sprite_x,x

		bcc no_msb_b1			; skip the MSB wrangling if carry isn't set

		lda b1_sprite_msb		; read the current MSB value
		eor msb_flag1			; toggle the bit for the sprite being processed
		sta b1_sprite_msb		; write the current MSB value

no_msb_b1
		asl msb_flag1			; shift the bit used for toggling MSB up for the next pass
		inx
		cpx #$08
		bne reposition_sprites_b1		
		
		
; split 2 is done, exit irq interrupt

		jmp irq_exit
				
		
; raster split 3 code ------------------------------------

irq_rout3

; set interrupt handler ready for split 1
		
		lda #$01
		sta raster_num
		lda #raster_1_pos
		sta $d012		
		
		lda #$00				; change colour to black border
		sta $d020				; for bottom third of screen
		
; recycle another 8 sprites in the very bottom part of the screen
; which are being used for the bottom half of the starfield
  

		lda #$ff				; turn on..
		sta $d015				; all 8 sprites!
		lda #$00				; make these sprites
		sta $d01c				; hires though!

		ldx #$00
		ldy #$00
draw_sprites_b2
		lda b2_sprite_x,x
		sta $d000,y
		lda b2_sprite_msb
		sta $d010		
		lda b2_sprite_y,x
		sta $d001,y
		lda b2_sprite_cols,x
		sta $d027,x
		lda b2_sprite_def,x
		sta $07f8,x
		iny
		iny
		inx
		cpx #$08
		bne draw_sprites_b2

		ldx #$00
		lda #$01
		sta msb_flag2			; set the temp value used for MSB juggling
reposition_sprites_b2
		lda b2_sprite_x,x
		clc
		adc b2_sprite_speed,x
		sta b2_sprite_x,x

		bcc no_msb_b2			; skip the MSB wrangling if carry isn't set

		lda b2_sprite_msb		; read the current MSB value
		eor msb_flag2			; toggle the bit for the sprite being processed
		sta b2_sprite_msb		; write the current MSB value

no_msb_b2
		asl msb_flag2			; shift the bit used for toggling MSB up for the next pass
		inx
		cpx #$08
		bne reposition_sprites_b2

		
; colour wash effect for bottom screen text lines

colour_wash

		ldx #$00
colourwash_loop
		lda colourwash_off,x
		clc
		adc colourwash_count
		and #$0f
		tay
		lda colourwash_greys,y
		sta $daa8,x
		lda colourwash_rainbow,y		
		sta $dbc0,x
		lda colourwash_blues,y		
		sta	$daf8,x
		sta $db48,x		
		lda colourwash_browns,y		
		sta $db20,x
		sta $db70,x		
		inx
		cpx #$28
		bne colourwash_loop

		ldx colourwash_timer
		inx
		cpx #$03
		bcc exit_wash
		inc colourwash_count
		ldx #$00
exit_wash	
		stx colourwash_timer
		
; test to see if logo pulse should be switched on

		dec	pulse_timer			; decrease the pulse_timer by 1!
		
		lda pulse_timer			; load up the pulse timer!
		cmp #$00				; have we reached zero yet?
		beq pulse_now			; yes? go down to 'pulse_now'!
								; no?
		jmp set_sync			; jump down to 'set_sync_
		
pulse_now

		lda #01					; switch on pulse by setting the
		sta pulse_flag			; pulse flag to '1'

		lda #$fa				; now reset our pulse timer to 250
		sta pulse_timer			; to wait another 5 seconds!
		
; set sync variable for main line code synchronisation

set_sync
	
		lda #$01				; set the sync flag to '1'		
		sta sync				; so the main code runs!
		
; restore registers and exit irq interrupt

irq_exit

		pla
		tay
		pla
		tax
		pla
nmi		rti

; end irq interrupt code =============================


; all data tables live here! ===============================


; colour wash data tables for text colour cycling

colourwash_off
		!byte $00,$01,$02,$01,$00,$01,$02,$01
		!byte $08,$07,$06,$05,$04,$03,$02,$04
		!byte $06,$08,$0a,$0c,$0e,$00,$0f,$0e
		!byte $0d,$0c,$0b,$0a,$09,$08,$07,$06
		!byte $0c,$0c,$0b,$0a,$0b,$0c,$0c,$0e		

colourwash_blues
		!byte $06,$04,$0e,$0e,$03,$01,$0f,$03
		!byte $0f,$01,$03,$0e,$0e,$04,$06,$0f
		
colourwash_browns
		!byte $09,$0f,$02,$0e,$08,$07,$01,$0f
		!byte $07,$0f,$01,$07,$08,$08,$02,$09
		
colourwash_greys
		!byte $0b,$0b,$0c,$0f,$0f,$0d,$01,$0d
		!byte $0d,$01,$01,$0d,$0f,$00,$0c,$0b
					
colourwash_rainbow
		!byte $06,$02,$04,$05,$03,$07,$01,$01
		!byte $01,$01,$01,$07,$03,$05,$04,$06

; text data for the rolling message

mess_text
		!scr ">  *  C o s i n e    S y s t e m s  *  <"
		!scr ">         p r e s e n t s . . .        <"		
		!scr ">  the rather * awkwardly * monikered  <"
		!scr "> >> The Unused Shmup Tune Selector << <"
		!scr ">                                      <"
		!scr "> Please use an 8580 SIDney sound chip <"		 
		!scr ">                                      <"
		!scr ">  Coding, graphics and music by aNdy  <"
		!scr ">                                      <"
		!scr "> Thanks goes to T.M.R, for letting me <"
		!scr ">  frolic in the Cosine Systems  6510  <"
		!scr ">  binary playground! Is that wise?!?  <"
		!scr ">                                      <"
		!scr "> Hopefully, I won't break anything... <"
		!scr ">   ...maybe only sprites in the MSB   <"		
		!scr ">                                      <"
		!scr "> As usual thanks goes to Moloch/Triad <"
		!scr ">   for his comments and suggestions   <"
		!scr ">                                      <"
		!scr "> Also on this occasion special thanks <"
		!scr ">  must be aimed and shot straight at  <"		
		!scr ">  Motion/Artstate, for his very kind  <"
		!scr ">  words of support and encouragement  <"
		!scr ">                                      <"
		!scr "> The tunes featured here were written <"
		!scr "> around 2 years ago at the request of <"
		!scr "> T.M.R, who wanted some new music for <"
		!scr "> the shooty shmup games he planned to <"
		!scr "> code as part of a rewrite of his old <"
		!scr "> assembly coding tutorial 'Hex Files' <"
		!scr ">                                      <"
		!scr ">  He *may* get round to rewriting it  <"
		!scr ">  one day...  breath not held...  ;)  <"			
		!scr ">                                      <"		
		!scr "> Cosine sends cordial salutations to: <"
		!scr ">  *  Absence  *  Abyss Connection  *  <"
		!scr ">   *  Arkanix Labs  *  Artstate  *    <"  
		!scr ">      *  Ate Bit  *  Atlantis  *      <"
		!scr ">    *  Booze Design  *  Camelot  *    <"				
		!scr ">    *  Censor Design  *  Chorus  *    <"
		!scr ">    *  Booze Design  *  Camelot  *    <"
		!scr ">    *  Chrome  *  CNCD  *  CPU  *     <"
		!scr ">       *  Crescent  *  Crest  *       <"										
		!scr ">  * Covert Bitops * Defence Force *   <"			
		!scr ">  *  Dekadence  *  Desire  *  DAC  *  <"
		!scr ">      *  DMAgic  *  Dual Crew  *      <"					
		!scr ">   *  Exclusive On  *  Fairlight  *   <"
		!scr ">    *  F4CG  * FIRE  *  Flat 3  *     <"								
		!scr ">     *  Focus  *  French Touch  *     <"
		!scr ">  * Genesis Project * Gheymaid Inc *  <"
		!scr ">       *  Hitmen  *  Hoaxers  *       <"		
		!scr ">  * Hokuto Force * Legion Of Doom *   <"
		!scr "> *  Level 64  *  Maniacs Of Noise  *  <"				
		!scr ">      *  Mayday  *  Meanteam  *       <"			
		!scr ">     *  Metalvotze  *  Noname  *      <"			
		!scr ">      *  Nostalgia  *  Nuance  *      <"			
		!scr ">     *  Offence  *  Onslaught  *      <"			
		!scr ">    *  Orb  *  Oxyron  *  Padua  *    <"		
		!scr ">      *  Performers  *  Plush  *      <"			
		!scr ">       *  PPCS  *  Psytronik  *       <"				
		!scr ">      *  Reptilia  *  Resource  *     <"	
		!scr ">    *  RGCD  *  Secure  *  SHAPE  *   <"			
		!scr ">      *  Side B  *  Singular  *       <"			
		!scr ">      *  Slash  *  Slipstream  *      <"			
		!scr ">   *  Success And TRC  *  Style  *    <"			
		!scr "> *  Suicyco Industries  *  Taquart  * <"			
		!scr ">   *  Tempest  *  TEK  *  Triad  *    <"					
		!scr ">  * Tristar And Red Sector * Viruz *  <"			
		!scr ">   * Vision * WOW * Wrath Designs *   <"	
		!scr ">        *  Xenon  *  Xentax  *        <"
		!scr ">                                      <"
		!scr ">    Please visit...  cosine.org.uk    <"						
		!scr ">                                      <"
		!scr ">   aNdy signing off in July 2019...   <"
		!scr ">                                      <"		
								
		!byte $00		; end of text marker			

; data for the tune selected left hand side arrows indicator
		
lefthilite		!byte $be,$be,$be,$be,$be,$be

; data for the tune selected right hand side arrows indicator

righthilite		!byte $bc,$bc,$bc,$bc,$bc,$bc

; sprite tables for 'pulse' behind logo (in the top split)

t_sprite_x		!byte $00,$00,$00,$00,$00,$00,$00,$00
t_sprite_y		!byte $39,$4e,$63,$78,$8d,$00,$00,$00
t_sprite_cols	!byte $01,$01,$01,$01,$01,$01,$01,$01
t_sprite_def	!byte $a0,$a1,$a2,$a3,$a4,$a5,$a6,$a7
t_sprite_speed	!byte $0c,$0c,$0c,$0c,$0c,$00,$00,$00
t_sprite_msb	!byte $00,$00,$00,$00,$00,$00,$00,$00
t_sprite_xreset !byte $00,$00,$00,$00,$00,$00,$00,$00

; sprite tables for first set of stars (second split)

b1_sprite_x		!byte $05,$64,$32,$f0,$e3,$b4,$a9,$e8
b1_sprite_y		!byte $ba,$c0,$c3,$c8,$c5,$c6,$c7,$c4
b1_sprite_cols	!byte $01,$01,$01,$0f,$0f,$0c,$0c,$0b
b1_sprite_def	!byte $a9,$a8,$a8,$a9,$a9,$a8,$aa,$aa
b1_sprite_speed	!byte $07,$06,$08,$05,$04,$03,$03,$02
b1_sprite_msb	!byte $00,$00,$00,$00,$00,$00,$00,$00

; sprite tables for second set of stars (third split)

b2_sprite_x		!byte $e9,$14,$fe,$0f,$a3,$09,$f0,$a1
b2_sprite_y		!byte $e4,$e5,$e6,$e7,$e8,$e9,$ea,$eb
b2_sprite_cols	!byte $01,$01,$01,$0f,$0f,$0c,$0c,$0b
b2_sprite_def	!byte $a8,$a9,$a8,$a9,$a8,$a9,$aa,$aa
b2_sprite_speed	!byte $08,$06,$07,$04,$05,$03,$03,$02
b2_sprite_msb	!byte $00,$00,$00,$00,$00,$00,$00,$00			

			
; data for the screen/colour ram lives down here...

; note: this data was generated using 'ChillED', a cross-dev
; C64 screen editor coded by aNdy/AL/Cosine

screen_ram			; the PETSCII logo and all the screen text
!byte $A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$81,$CE,$84,$99,$A0
!byte $A0,$A0,$7E,$7B,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$A0,$A0,$7E,$7B,$E2,$E2,$E2,$E2,$6C,$7C,$A0,$E2,$E2,$E2,$E2,$E2,$E2,$A0,$A0,$7E,$7B,$E2,$E2,$E2,$E2,$A0
!byte $A0,$7E,$FE,$61,$69,$DC,$A2,$61,$7C,$69,$69,$DC,$A2,$FC,$7C,$7E,$FE,$61,$69,$DC,$A2,$61,$E1,$FC,$7C,$7C,$69,$69,$DC,$A2,$FC,$7C,$7E,$FE,$61,$69,$DC,$A2,$61,$DC
!byte $A0,$E1,$E9,$61,$7B,$FB,$EC,$6C,$FC,$20,$7B,$7B,$FB,$A5,$61,$E1,$E9,$61,$7B,$FB,$EC,$6C,$E1,$E9,$61,$FC,$20,$7B,$7B,$FB,$A5,$61,$E1,$E9,$61,$7B,$FB,$EC,$6C,$DC
!byte $A0,$E1,$A0,$61,$5E,$7C,$6C,$5E,$7E,$FE,$61,$5E,$E1,$AC,$61,$E1,$A0,$61,$5E,$7C,$6C,$5E,$E1,$A0,$61,$7E,$FE,$61,$5E,$E1,$AC,$61,$E1,$A0,$61,$DC,$7C,$6C,$DC,$A0
!byte $A0,$E1,$DC,$61,$5E,$5E,$5E,$5E,$E1,$DC,$61,$DC,$E1,$DC,$61,$E1,$DC,$61,$68,$68,$62,$7C,$E1,$DC,$61,$E1,$DC,$61,$5E,$E1,$DC,$61,$E1,$DC,$61,$68,$62,$20,$FB,$A0
!byte $A0,$7C,$E2,$7F,$7C,$E6,$A0,$DC,$7C,$E2,$7F,$7C,$7C,$E2,$7F,$20,$E2,$7E,$7C,$E2,$E2,$7F,$7C,$E2,$7E,$7C,$E2,$7F,$7C,$7C,$E2,$7F,$7C,$E2,$7F,$E2,$E2,$7F,$E1,$A0
!byte $A0,$E1,$A1,$61,$6C,$E2,$FB,$E8,$E1,$A1,$61,$FE,$E1,$A1,$61,$7C,$FB,$5E,$5C,$FB,$A1,$61,$E1,$A1,$61,$E1,$A1,$61,$FE,$E1,$A1,$61,$E1,$A1,$61,$FE,$E1,$20,$FE,$A0
!byte $A0,$E1,$AE,$61,$DC,$E1,$7C,$A0,$E1,$AE,$61,$DC,$E1,$AE,$61,$E1,$7C,$5E,$5E,$E1,$AE,$61,$E1,$AE,$61,$E1,$AE,$61,$5E,$E1,$AE,$61,$E1,$AE,$61,$5E,$E1,$FC,$7C,$A0
!byte $A0,$E1,$BB,$FC,$7C,$E1,$FC,$7C,$E1,$BB,$FC,$7C,$E1,$BA,$61,$E1,$FC,$7C,$E2,$E1,$BA,$61,$E1,$BB,$61,$E1,$BB,$61,$5E,$E1,$BA,$61,$E1,$BB,$61,$E2,$E1,$BA,$61,$A0
!byte $A0,$7B,$FB,$A2,$A0,$E1,$E9,$61,$7B,$FB,$A2,$A0,$E1,$E9,$61,$E1,$E9,$61,$A0,$A0,$EC,$6C,$E1,$E9,$61,$7B,$FB,$61,$5E,$E1,$E9,$61,$7B,$FB,$A2,$A0,$E1,$E9,$61,$A0
!byte $A0,$A0,$68,$68,$68,$7B,$FB,$61,$E8,$68,$68,$68,$E1,$EC,$6C,$7B,$FB,$61,$68,$68,$68,$A0,$E1,$EC,$6C,$5E,$68,$68,$5E,$E1,$EC,$6C,$5E,$68,$68,$68,$68,$FB,$61,$A0
!byte $A0,$A0,$A0,$A0,$A0,$A0,$7B,$7B,$DC,$A0,$A0,$A0,$6C,$6C,$DC,$A0,$7B,$7B,$DC,$A0,$A0,$A0,$6C,$6C,$A0,$A0,$A0,$A0,$A0,$6C,$6C,$DC,$A0,$A0,$A0,$A0,$A0,$7B,$7B,$A0
!byte $A0,$80,$A0,$A0,$A0,$A0,$FC,$68,$DC,$A0,$A0,$A0,$62,$FE,$A0,$A0,$FC,$68,$A0,$A0,$A0,$A0,$68,$FE,$A0,$A0,$A0,$A0,$A0,$68,$FE,$A0,$A0,$A0,$A0,$A0,$A0,$FC,$68,$DC
!byte $A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0,$A0
!byte $A0,$ED,$C0,$BE,$A0,$94,$C8,$85,$A0,$95,$CE,$95,$A4,$85,$C4,$A0,$A4,$88,$8D,$D5,$90,$A0,$94,$D5,$8E,$9C,$A0,$93,$C5,$8C,$C5,$83,$D4,$B0,$92,$A0,$BC,$C0,$EE,$A0
!byte $E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2,$E2
!byte $4E,$15,$0D,$02,$05,$12,$20,$0B,$05,$19,$13,$20,$14,$0F,$20,$10,$0C,$01,$19,$20,$3C,$3E,$20,$52,$15,$0E,$53,$14,$0F,$10,$20,$0B,$05,$19,$20,$13,$14,$0F,$10,$13
!byte $7A,$20,$20,$20,$20,$20,$20,$20,$20,$FA,$20,$7A,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$FA,$20,$20,$20,$20,$20,$20,$20,$7A,$FA,$20,$20,$20,$20,$FA,$7A,$20
!byte $20,$20,$20,$20,$20,$20,$20,$1B,$31,$1D,$20,$55,$0E,$15,$13,$05,$04,$20,$54,$09,$14,$0C,$05,$20,$54,$12,$01,$03,$0B,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20
!byte $20,$20,$20,$20,$20,$20,$20,$1B,$32,$1D,$20,$55,$0E,$15,$13,$05,$04,$20,$47,$05,$14,$20,$52,$05,$01,$04,$19,$20,$54,$12,$01,$03,$0B,$20,$20,$20,$20,$20,$20,$20
!byte $20,$20,$20,$20,$20,$20,$20,$1B,$33,$1D,$20,$55,$0E,$15,$13,$05,$04,$20,$49,$0E,$2D,$07,$01,$0D,$05,$20,$54,$12,$01,$03,$0B,$20,$20,$20,$20,$20,$20,$20,$20,$20
!byte $20,$20,$20,$20,$20,$20,$20,$1B,$34,$1D,$20,$55,$0E,$15,$13,$05,$04,$20,$47,$01,$0D,$05,$20,$0F,$16,$05,$12,$20,$54,$12,$01,$03,$0B,$20,$20,$20,$20,$20,$20,$20
!byte $20,$20,$FA,$7A,$20,$20,$7A,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$FA,$20,$20,$20,$20,$20,$20,$20,$20,$7A,$20,$20,$FA
!byte $3E,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$20,$3C

colour_ram			; colour data for the PETSCII logo and text
!byte $06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06
!byte $06,$06,$06,$0D,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$0D,$06,$06,$06,$06,$0D,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$0D,$06,$06,$06,$06,$06
!byte $06,$06,$0D,$03,$0D,$03,$0E,$04,$0D,$0D,$0D,$03,$0E,$04,$06,$06,$0D,$03,$0D,$03,$0E,$04,$0D,$03,$06,$0D,$0D,$0D,$03,$0E,$04,$06,$06,$0D,$03,$0D,$03,$0E,$04,$06
!byte $06,$0D,$03,$0E,$06,$0E,$04,$06,$06,$01,$0E,$06,$03,$0E,$04,$0D,$03,$0E,$06,$0E,$04,$06,$0D,$03,$0E,$06,$01,$0E,$06,$03,$0E,$04,$0D,$03,$0E,$06,$0E,$04,$06,$06
!byte $06,$03,$0E,$04,$06,$04,$06,$06,$06,$0E,$04,$06,$0E,$04,$04,$03,$0E,$04,$06,$04,$06,$06,$03,$0E,$04,$06,$0E,$04,$06,$0E,$04,$04,$03,$0E,$04,$06,$04,$06,$06,$06
!byte $06,$0E,$04,$06,$06,$06,$06,$06,$0E,$04,$06,$06,$04,$04,$06,$0E,$04,$06,$0E,$04,$04,$06,$0E,$04,$06,$0E,$04,$06,$06,$04,$04,$06,$0E,$04,$06,$0E,$04,$01,$06,$06
!byte $06,$04,$06,$01,$06,$06,$06,$06,$04,$06,$01,$06,$04,$06,$01,$06,$06,$06,$04,$04,$06,$01,$04,$06,$06,$04,$06,$01,$06,$04,$06,$01,$04,$06,$01,$04,$06,$01,$06,$06
!byte $06,$01,$07,$0A,$06,$06,$06,$06,$01,$07,$0A,$06,$01,$07,$0A,$06,$06,$06,$06,$01,$07,$0A,$01,$07,$0A,$01,$07,$0A,$06,$01,$07,$0A,$01,$07,$0A,$06,$01,$06,$06,$06
!byte $06,$07,$0A,$08,$06,$0A,$06,$06,$07,$0A,$08,$06,$07,$0A,$08,$0A,$06,$06,$06,$07,$0A,$08,$07,$0A,$08,$07,$0A,$08,$06,$07,$0A,$08,$07,$0A,$08,$06,$07,$0A,$06,$06
!byte $06,$0A,$08,$02,$06,$08,$08,$06,$0A,$08,$02,$06,$0A,$08,$02,$08,$08,$06,$06,$0A,$08,$02,$0A,$08,$02,$0A,$08,$02,$06,$0A,$08,$02,$0A,$08,$02,$06,$0A,$08,$02,$06
!byte $06,$06,$08,$02,$09,$02,$02,$09,$06,$08,$02,$09,$02,$02,$09,$02,$02,$09,$02,$08,$09,$06,$02,$02,$09,$06,$02,$09,$06,$02,$02,$09,$06,$08,$02,$09,$02,$02,$09,$06
!byte $06,$06,$06,$06,$06,$06,$09,$09,$06,$06,$06,$06,$09,$09,$06,$06,$09,$09,$06,$06,$06,$06,$09,$09,$06,$06,$06,$06,$06,$09,$09,$06,$06,$06,$06,$06,$06,$09,$09,$06
!byte $06,$06,$06,$06,$06,$06,$06,$09,$06,$06,$06,$06,$09,$06,$06,$06,$06,$09,$06,$06,$06,$06,$09,$06,$06,$06,$06,$06,$06,$09,$06,$06,$06,$06,$06,$06,$06,$06,$09,$06
!byte $06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06
!byte $06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06
!byte $06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06
!byte $06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06
!byte $06,$06,$06,$06,$06,$06,$00,$06,$06,$06,$06,$00,$06,$06,$00,$06,$06,$06,$06,$00,$06,$06,$0B,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$00,$06,$06,$06,$06,$06
!byte $0B,$00,$00,$00,$00,$0B,$00,$00,$00,$0B,$00,$0B,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$0B,$00,$00,$00,$00,$00,$00,$00,$0B,$0B,$00,$00,$00,$00,$0B,$0B,$00
!byte $00,$00,$00,$00,$00,$00,$00,$06,$06,$06,$00,$06,$06,$06,$06,$06,$06,$00,$06,$06,$06,$06,$06,$00,$06,$06,$06,$06,$06,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00
!byte $00,$00,$00,$00,$00,$00,$00,$06,$06,$06,$00,$06,$06,$06,$06,$06,$06,$0B,$06,$06,$06,$00,$06,$06,$06,$06,$06,$00,$06,$06,$06,$06,$06,$00,$00,$00,$00,$00,$00,$00
!byte $00,$00,$00,$00,$00,$00,$00,$06,$06,$06,$00,$06,$06,$06,$06,$06,$06,$00,$06,$06,$06,$06,$06,$06,$06,$00,$06,$06,$06,$06,$06,$00,$00,$00,$00,$0B,$00,$00,$00,$00
!byte $00,$00,$00,$00,$00,$00,$00,$06,$06,$06,$00,$06,$06,$06,$06,$06,$06,$0B,$06,$06,$06,$06,$00,$06,$06,$06,$06,$00,$06,$06,$06,$06,$06,$00,$00,$00,$00,$00,$00,$00
!byte $00,$00,$0B,$0B,$00,$00,$0B,$00,$00,$00,$00,$0B,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$00,$0B,$00,$00,$00,$00,$00,$00,$00,$00,$0B,$00,$00,$0B
!byte $06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06,$06


; end of code!!! ========================================================================
